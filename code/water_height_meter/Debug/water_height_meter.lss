
water_height_meter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000061c  00800100  0000059e  00000632  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000059e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000008  0080071c  0080071c  00000c4e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c4e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c80  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000d0  00000000  00000000  00000cc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001206  00000000  00000000  00000d90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ad8  00000000  00000000  00001f96  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000879  00000000  00000000  00002a6e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001dc  00000000  00000000  000032e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000056c  00000000  00000000  000034c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000684  00000000  00000000  00003a30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  000040b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	33 c0       	rjmp	.+102    	; 0x68 <__ctors_end>
   2:	00 00       	nop
   4:	4c c0       	rjmp	.+152    	; 0x9e <__bad_interrupt>
   6:	00 00       	nop
   8:	4a c0       	rjmp	.+148    	; 0x9e <__bad_interrupt>
   a:	00 00       	nop
   c:	48 c0       	rjmp	.+144    	; 0x9e <__bad_interrupt>
   e:	00 00       	nop
  10:	46 c0       	rjmp	.+140    	; 0x9e <__bad_interrupt>
  12:	00 00       	nop
  14:	44 c0       	rjmp	.+136    	; 0x9e <__bad_interrupt>
  16:	00 00       	nop
  18:	42 c0       	rjmp	.+132    	; 0x9e <__bad_interrupt>
  1a:	00 00       	nop
  1c:	40 c0       	rjmp	.+128    	; 0x9e <__bad_interrupt>
  1e:	00 00       	nop
  20:	3e c0       	rjmp	.+124    	; 0x9e <__bad_interrupt>
  22:	00 00       	nop
  24:	3c c0       	rjmp	.+120    	; 0x9e <__bad_interrupt>
  26:	00 00       	nop
  28:	54 c0       	rjmp	.+168    	; 0xd2 <__vector_10>
  2a:	00 00       	nop
  2c:	39 c0       	rjmp	.+114    	; 0xa0 <__vector_11>
  2e:	00 00       	nop
  30:	36 c0       	rjmp	.+108    	; 0x9e <__bad_interrupt>
  32:	00 00       	nop
  34:	34 c0       	rjmp	.+104    	; 0x9e <__bad_interrupt>
  36:	00 00       	nop
  38:	32 c0       	rjmp	.+100    	; 0x9e <__bad_interrupt>
  3a:	00 00       	nop
  3c:	30 c0       	rjmp	.+96     	; 0x9e <__bad_interrupt>
  3e:	00 00       	nop
  40:	2e c0       	rjmp	.+92     	; 0x9e <__bad_interrupt>
  42:	00 00       	nop
  44:	2c c0       	rjmp	.+88     	; 0x9e <__bad_interrupt>
  46:	00 00       	nop
  48:	2a c0       	rjmp	.+84     	; 0x9e <__bad_interrupt>
  4a:	00 00       	nop
  4c:	28 c0       	rjmp	.+80     	; 0x9e <__bad_interrupt>
  4e:	00 00       	nop
  50:	26 c0       	rjmp	.+76     	; 0x9e <__bad_interrupt>
  52:	00 00       	nop
  54:	24 c0       	rjmp	.+72     	; 0x9e <__bad_interrupt>
  56:	00 00       	nop
  58:	22 c0       	rjmp	.+68     	; 0x9e <__bad_interrupt>
  5a:	00 00       	nop
  5c:	20 c0       	rjmp	.+64     	; 0x9e <__bad_interrupt>
  5e:	00 00       	nop
  60:	1e c0       	rjmp	.+60     	; 0x9e <__bad_interrupt>
  62:	00 00       	nop
  64:	1c c0       	rjmp	.+56     	; 0x9e <__bad_interrupt>
	...

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	17 e0       	ldi	r17, 0x07	; 7
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee e9       	ldi	r30, 0x9E	; 158
  7c:	f5 e0       	ldi	r31, 0x05	; 5
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ac 31       	cpi	r26, 0x1C	; 28
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	ac e1       	ldi	r26, 0x1C	; 28
  8e:	b7 e0       	ldi	r27, 0x07	; 7
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a4 32       	cpi	r26, 0x24	; 36
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	ba d0       	rcall	.+372    	; 0x210 <main>
  9c:	7e c2       	rjmp	.+1276   	; 0x59a <_exit>

0000009e <__bad_interrupt>:
  9e:	b0 cf       	rjmp	.-160    	; 0x0 <__vectors>

000000a0 <__vector_11>:

uint16_t counts;
uint32_t dist;

ISR(TIMER1_COMPA_vect)
{
  a0:	1f 92       	push	r1
  a2:	0f 92       	push	r0
  a4:	0f b6       	in	r0, 0x3f	; 63
  a6:	0f 92       	push	r0
  a8:	11 24       	eor	r1, r1
  aa:	8f 93       	push	r24
  ac:	9f 93       	push	r25
    //Generate a 12us pulse to trigger the HC-SR04
    HCSR_TRIGGER_PORT ^= (1 << HCSR_TRIGGER);
  ae:	9b b1       	in	r25, 0x0b	; 11
  b0:	80 e4       	ldi	r24, 0x40	; 64
  b2:	98 27       	eor	r25, r24
  b4:	9b b9       	out	0x0b, r25	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  b6:	95 e3       	ldi	r25, 0x35	; 53
  b8:	9a 95       	dec	r25
  ba:	f1 f7       	brne	.-4      	; 0xb8 <__vector_11+0x18>
  bc:	00 00       	nop
    _delay_us(10);
    HCSR_TRIGGER_PORT ^= (1 << HCSR_TRIGGER);
  be:	9b b1       	in	r25, 0x0b	; 11
  c0:	89 27       	eor	r24, r25
  c2:	8b b9       	out	0x0b, r24	; 11
}
  c4:	9f 91       	pop	r25
  c6:	8f 91       	pop	r24
  c8:	0f 90       	pop	r0
  ca:	0f be       	out	0x3f, r0	; 63
  cc:	0f 90       	pop	r0
  ce:	1f 90       	pop	r1
  d0:	18 95       	reti

000000d2 <__vector_10>:
*  interrupt is enabled.
*/
/************************************************************************/

ISR(TIMER1_CAPT_vect)
{
  d2:	1f 92       	push	r1
  d4:	0f 92       	push	r0
  d6:	0f b6       	in	r0, 0x3f	; 63
  d8:	0f 92       	push	r0
  da:	11 24       	eor	r1, r1
  dc:	0f 93       	push	r16
  de:	1f 93       	push	r17
  e0:	2f 93       	push	r18
  e2:	3f 93       	push	r19
  e4:	4f 93       	push	r20
  e6:	5f 93       	push	r21
  e8:	6f 93       	push	r22
  ea:	7f 93       	push	r23
  ec:	8f 93       	push	r24
  ee:	9f 93       	push	r25
  f0:	af 93       	push	r26
  f2:	bf 93       	push	r27
  f4:	ef 93       	push	r30
  f6:	ff 93       	push	r31
    static uint16_t rising = 0, falling = 0;                    // For storing of rising/falling data
    
    if (TCCR1B & (1 << ICES1))                                  // Check input capture reg PB0
  f8:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
  fc:	86 ff       	sbrs	r24, 6
  fe:	0e c0       	rjmp	.+28     	; 0x11c <__vector_10+0x4a>
    {
        TCCR1B &= ~(1 << ICES1);                                // Set to falling edge
 100:	e1 e8       	ldi	r30, 0x81	; 129
 102:	f0 e0       	ldi	r31, 0x00	; 0
 104:	80 81       	ld	r24, Z
 106:	8f 7b       	andi	r24, 0xBF	; 191
 108:	80 83       	st	Z, r24
        rising = ICR1;                                          // Read value ticks
 10a:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
 10e:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
 112:	90 93 1d 07 	sts	0x071D, r25	; 0x80071d <__data_end+0x1>
 116:	80 93 1c 07 	sts	0x071C, r24	; 0x80071c <__data_end>
 11a:	40 c0       	rjmp	.+128    	; 0x19c <__vector_10+0xca>
    } else {
        TCCR1B |= (1 << ICES1);                                 // Rest to rising edge
 11c:	e1 e8       	ldi	r30, 0x81	; 129
 11e:	f0 e0       	ldi	r31, 0x00	; 0
 120:	80 81       	ld	r24, Z
 122:	80 64       	ori	r24, 0x40	; 64
 124:	80 83       	st	Z, r24
        falling = ICR1;                                         // Read value ticks
 126:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <__TEXT_REGION_LENGTH__+0x7f8086>
 12a:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <__TEXT_REGION_LENGTH__+0x7f8087>
        counts = falling - rising;                              // Calc. difference between start and stop of the pulse
 12e:	20 91 1c 07 	lds	r18, 0x071C	; 0x80071c <__data_end>
 132:	30 91 1d 07 	lds	r19, 0x071D	; 0x80071d <__data_end+0x1>
 136:	82 1b       	sub	r24, r18
 138:	93 0b       	sbc	r25, r19
 13a:	90 93 23 07 	sts	0x0723, r25	; 0x800723 <counts+0x1>
 13e:	80 93 22 07 	sts	0x0722, r24	; 0x800722 <counts>
        dist = (US_PER_COUNT * (uint32_t)counts * 10) / 58;     // Convert to distance (in mm) time in us/58 -> distance in cm time in us/5.8 -> distance in mm
 142:	a0 e0       	ldi	r26, 0x00	; 0
 144:	b0 e0       	ldi	r27, 0x00	; 0
 146:	88 0f       	add	r24, r24
 148:	99 1f       	adc	r25, r25
 14a:	aa 1f       	adc	r26, r26
 14c:	bb 1f       	adc	r27, r27
 14e:	88 0f       	add	r24, r24
 150:	99 1f       	adc	r25, r25
 152:	aa 1f       	adc	r26, r26
 154:	bb 1f       	adc	r27, r27
 156:	88 0f       	add	r24, r24
 158:	99 1f       	adc	r25, r25
 15a:	aa 1f       	adc	r26, r26
 15c:	bb 1f       	adc	r27, r27
 15e:	ac 01       	movw	r20, r24
 160:	bd 01       	movw	r22, r26
 162:	44 0f       	add	r20, r20
 164:	55 1f       	adc	r21, r21
 166:	66 1f       	adc	r22, r22
 168:	77 1f       	adc	r23, r23
 16a:	44 0f       	add	r20, r20
 16c:	55 1f       	adc	r21, r21
 16e:	66 1f       	adc	r22, r22
 170:	77 1f       	adc	r23, r23
 172:	8c 01       	movw	r16, r24
 174:	9d 01       	movw	r18, r26
 176:	04 0f       	add	r16, r20
 178:	15 1f       	adc	r17, r21
 17a:	26 1f       	adc	r18, r22
 17c:	37 1f       	adc	r19, r23
 17e:	c9 01       	movw	r24, r18
 180:	b8 01       	movw	r22, r16
 182:	2a e3       	ldi	r18, 0x3A	; 58
 184:	30 e0       	ldi	r19, 0x00	; 0
 186:	40 e0       	ldi	r20, 0x00	; 0
 188:	50 e0       	ldi	r21, 0x00	; 0
 18a:	b2 d1       	rcall	.+868    	; 0x4f0 <__udivmodsi4>
 18c:	20 93 1e 07 	sts	0x071E, r18	; 0x80071e <dist>
 190:	30 93 1f 07 	sts	0x071F, r19	; 0x80071f <dist+0x1>
 194:	40 93 20 07 	sts	0x0720, r20	; 0x800720 <dist+0x2>
 198:	50 93 21 07 	sts	0x0721, r21	; 0x800721 <dist+0x3>
    }
}
 19c:	ff 91       	pop	r31
 19e:	ef 91       	pop	r30
 1a0:	bf 91       	pop	r27
 1a2:	af 91       	pop	r26
 1a4:	9f 91       	pop	r25
 1a6:	8f 91       	pop	r24
 1a8:	7f 91       	pop	r23
 1aa:	6f 91       	pop	r22
 1ac:	5f 91       	pop	r21
 1ae:	4f 91       	pop	r20
 1b0:	3f 91       	pop	r19
 1b2:	2f 91       	pop	r18
 1b4:	1f 91       	pop	r17
 1b6:	0f 91       	pop	r16
 1b8:	0f 90       	pop	r0
 1ba:	0f be       	out	0x3f, r0	; 63
 1bc:	0f 90       	pop	r0
 1be:	1f 90       	pop	r1
 1c0:	18 95       	reti

000001c2 <init_ultrasonic_sensor>:

void init_ultrasonic_sensor()
{
    // Setup trigger output
    HCSR_TRIGGER_DDR |= (1 << HCSR_TRIGGER);
 1c2:	8a b1       	in	r24, 0x0a	; 10
 1c4:	80 64       	ori	r24, 0x40	; 64
 1c6:	8a b9       	out	0x0a, r24	; 10

    //****TIMER1 INIT Input capture init ****//
    TCCR1B |= (1 << ICNC1);                     // Noice reduction enable
 1c8:	e1 e8       	ldi	r30, 0x81	; 129
 1ca:	f0 e0       	ldi	r31, 0x00	; 0
 1cc:	80 81       	ld	r24, Z
 1ce:	80 68       	ori	r24, 0x80	; 128
 1d0:	80 83       	st	Z, r24
    TCCR1B |= (1 << CS10) | (1 << CS11);        // Prescale to 64
 1d2:	80 81       	ld	r24, Z
 1d4:	83 60       	ori	r24, 0x03	; 3
 1d6:	80 83       	st	Z, r24
    TCCR1B |= (1 << WGM12);                     // CTC
 1d8:	80 81       	ld	r24, Z
 1da:	88 60       	ori	r24, 0x08	; 8
 1dc:	80 83       	st	Z, r24
    TIMSK1 |= (1 << ICIE1) | (1 << OCIE1A);     // Enable timer 1 interrupt + enable OC interrupt
 1de:	af e6       	ldi	r26, 0x6F	; 111
 1e0:	b0 e0       	ldi	r27, 0x00	; 0
 1e2:	8c 91       	ld	r24, X
 1e4:	82 62       	ori	r24, 0x22	; 34
 1e6:	8c 93       	st	X, r24
    TCCR1B |= (1 << ICES1);                     
 1e8:	80 81       	ld	r24, Z
 1ea:	80 64       	ori	r24, 0x40	; 64
 1ec:	80 83       	st	Z, r24

    OCR1A = 17500;                              // Calculate TOP (70ms runtime for one cycle): 16MHz/64 = 25000 count/sec. = 25000/1000 = 2500 count/us / 100*70 = 17500 count/70ms    
 1ee:	8c e5       	ldi	r24, 0x5C	; 92
 1f0:	94 e4       	ldi	r25, 0x44	; 68
 1f2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 1f6:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>

    sei();                                      //activate global interrupt
 1fa:	78 94       	sei
 1fc:	08 95       	ret

000001fe <get_dist>:
}

uint32_t get_dist()
{
    return dist;                                // return distance in mm
 1fe:	60 91 1e 07 	lds	r22, 0x071E	; 0x80071e <dist>
 202:	70 91 1f 07 	lds	r23, 0x071F	; 0x80071f <dist+0x1>
 206:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <dist+0x2>
 20a:	90 91 21 07 	lds	r25, 0x0721	; 0x800721 <dist+0x3>
}
 20e:	08 95       	ret

00000210 <main>:
 */ 

#include "main.h"

int main(void)
{
 210:	cf 93       	push	r28
 212:	df 93       	push	r29
 214:	00 d0       	rcall	.+0      	; 0x216 <main+0x6>
 216:	00 d0       	rcall	.+0      	; 0x218 <main+0x8>
 218:	1f 92       	push	r1
 21a:	cd b7       	in	r28, 0x3d	; 61
 21c:	de b7       	in	r29, 0x3e	; 62
    LCD_init();                 // LCD initialization
 21e:	67 d0       	rcall	.+206    	; 0x2ee <LCD_init>
    init_ultrasonic_sensor();   // Ultrasonic init
 220:	d0 df       	rcall	.-96     	; 0x1c2 <init_ultrasonic_sensor>
    
    // show init screen, sleep 5s
    LCD_write_init();  
 222:	ff d0       	rcall	.+510    	; 0x422 <LCD_write_init>
 224:	40 e0       	ldi	r20, 0x00	; 0
    LCD_write_whole_screen((unsigned char *)init_msg_1, 504, 0);
 226:	50 e0       	ldi	r21, 0x00	; 0
 228:	68 ef       	ldi	r22, 0xF8	; 248
 22a:	71 e0       	ldi	r23, 0x01	; 1
 22c:	83 e2       	ldi	r24, 0x23	; 35
 22e:	95 e0       	ldi	r25, 0x05	; 5
 230:	d9 d0       	rcall	.+434    	; 0x3e4 <LCD_write_whole_screen>
 232:	2f ef       	ldi	r18, 0xFF	; 255
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 234:	87 ea       	ldi	r24, 0xA7	; 167
 236:	91 e6       	ldi	r25, 0x61	; 97
 238:	21 50       	subi	r18, 0x01	; 1
 23a:	80 40       	sbci	r24, 0x00	; 0
 23c:	90 40       	sbci	r25, 0x00	; 0
 23e:	e1 f7       	brne	.-8      	; 0x238 <main+0x28>
 240:	00 c0       	rjmp	.+0      	; 0x242 <main+0x32>
    _delay_ms(2000);
    LCD_clear();
 242:	00 00       	nop
 244:	3e d0       	rcall	.+124    	; 0x2c2 <LCD_clear>
    /* Replace with your application code */
    uint32_t distance_val = 0;
    char distance_str[5];
    while (1) 
    {
        LCD_clear();                                    // Clear lcd
 246:	3d d0       	rcall	.+122    	; 0x2c2 <LCD_clear>
 248:	da df       	rcall	.-76     	; 0x1fe <get_dist>
        distance_val = (uint32_t) get_dist();           // Get distance in mm
 24a:	fd d0       	rcall	.+506    	; 0x446 <__fixunssfsi>
 24c:	dc 01       	movw	r26, r24
 24e:	cb 01       	movw	r24, r22
 250:	4a e0       	ldi	r20, 0x0A	; 10
 252:	be 01       	movw	r22, r28
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__itoa_ncheck (int, char *, unsigned char);
	return __itoa_ncheck (__val, __s, __radix);
 254:	6f 5f       	subi	r22, 0xFF	; 255
 256:	7f 4f       	sbci	r23, 0xFF	; 255
 258:	6d d1       	rcall	.+730    	; 0x534 <__itoa_ncheck>
 25a:	ae 01       	movw	r20, r28
 25c:	4f 5f       	subi	r20, 0xFF	; 255
        itoa(distance_val, distance_str, 10);           // Convert to str
        LCD_write_english_string(0, 0, distance_str);   // Display
 25e:	5f 4f       	sbci	r21, 0xFF	; 255
 260:	60 e0       	ldi	r22, 0x00	; 0
 262:	80 e0       	ldi	r24, 0x00	; 0
 264:	b2 d0       	rcall	.+356    	; 0x3ca <LCD_write_english_string>
 266:	40 e0       	ldi	r20, 0x00	; 0
 268:	51 e0       	ldi	r21, 0x01	; 1
        LCD_write_english_string(6, 0, "mm");
 26a:	60 e0       	ldi	r22, 0x00	; 0
 26c:	86 e0       	ldi	r24, 0x06	; 6
 26e:	ad d0       	rcall	.+346    	; 0x3ca <LCD_write_english_string>
 270:	2f ef       	ldi	r18, 0xFF	; 255
 272:	83 ed       	ldi	r24, 0xD3	; 211
 274:	90 e3       	ldi	r25, 0x30	; 48
 276:	21 50       	subi	r18, 0x01	; 1
 278:	80 40       	sbci	r24, 0x00	; 0
 27a:	90 40       	sbci	r25, 0x00	; 0
 27c:	e1 f7       	brne	.-8      	; 0x276 <main+0x66>
 27e:	00 c0       	rjmp	.+0      	; 0x280 <main+0x70>
 280:	00 00       	nop
 282:	e1 cf       	rjmp	.-62     	; 0x246 <main+0x36>

00000284 <LCD_write_byte>:

void LCD_write_byte(unsigned char dat, unsigned char command)
{
    unsigned char i;

    if (command == 1)
 284:	61 30       	cpi	r22, 0x01	; 1
 286:	29 f4       	brne	.+10     	; 0x292 <LCD_write_byte+0xe>
    LCD_DC_clr;
 288:	95 b1       	in	r25, 0x05	; 5
 28a:	97 7f       	andi	r25, 0xF7	; 247
 28c:	95 b9       	out	0x05, r25	; 5
        LCD_write_byte(0, 0);
    }
}

void LCD_write_byte(unsigned char dat, unsigned char command)
{
 28e:	20 e0       	ldi	r18, 0x00	; 0
 290:	15 c0       	rjmp	.+42     	; 0x2bc <LCD_write_byte+0x38>
    unsigned char i;

    if (command == 1)
    LCD_DC_clr;
    else
    LCD_DC_set;
 292:	95 b1       	in	r25, 0x05	; 5
 294:	98 60       	ori	r25, 0x08	; 8
 296:	95 b9       	out	0x05, r25	; 5
 298:	fa cf       	rjmp	.-12     	; 0x28e <LCD_write_byte+0xa>

    for(i = 0; i < 8; i++)
    {
        if(dat&0x80)
 29a:	88 23       	and	r24, r24
 29c:	24 f4       	brge	.+8      	; 0x2a6 <LCD_write_byte+0x22>
            SDIN_set;
 29e:	95 b1       	in	r25, 0x05	; 5
 2a0:	94 60       	ori	r25, 0x04	; 4
 2a2:	95 b9       	out	0x05, r25	; 5
 2a4:	03 c0       	rjmp	.+6      	; 0x2ac <LCD_write_byte+0x28>
        else
            SDIN_clr;
 2a6:	95 b1       	in	r25, 0x05	; 5
 2a8:	9b 7f       	andi	r25, 0xFB	; 251
 2aa:	95 b9       	out	0x05, r25	; 5
               
        SCLK_clr;
 2ac:	95 b1       	in	r25, 0x05	; 5
 2ae:	9d 7f       	andi	r25, 0xFD	; 253
 2b0:	95 b9       	out	0x05, r25	; 5
        dat = dat << 1;
 2b2:	88 0f       	add	r24, r24
        SCLK_set;
 2b4:	95 b1       	in	r25, 0x05	; 5
 2b6:	92 60       	ori	r25, 0x02	; 2
 2b8:	95 b9       	out	0x05, r25	; 5
    if (command == 1)
    LCD_DC_clr;
    else
    LCD_DC_set;

    for(i = 0; i < 8; i++)
 2ba:	2f 5f       	subi	r18, 0xFF	; 255
 2bc:	28 30       	cpi	r18, 0x08	; 8
 2be:	68 f3       	brcs	.-38     	; 0x29a <LCD_write_byte+0x16>
               
        SCLK_clr;
        dat = dat << 1;
        SCLK_set;
    }
}
 2c0:	08 95       	ret

000002c2 <LCD_clear>:
    LCD_write_byte(0x0c, 1); // set LCD mode,display normally
    LCD_clear();             // clear the LCD
}

void LCD_clear()
{
 2c2:	cf 93       	push	r28
 2c4:	df 93       	push	r29
    LCD_write_byte(0x0c, 1);
 2c6:	61 e0       	ldi	r22, 0x01	; 1
 2c8:	8c e0       	ldi	r24, 0x0C	; 12
 2ca:	dc df       	rcall	.-72     	; 0x284 <LCD_write_byte>
    LCD_write_byte(0x80, 1);
 2cc:	61 e0       	ldi	r22, 0x01	; 1
 2ce:	80 e8       	ldi	r24, 0x80	; 128
 2d0:	d9 df       	rcall	.-78     	; 0x284 <LCD_write_byte>

    for (unsigned int i = 0; i < NUM_OF_CELLS; i++)
 2d2:	c0 e0       	ldi	r28, 0x00	; 0
 2d4:	d0 e0       	ldi	r29, 0x00	; 0
 2d6:	04 c0       	rjmp	.+8      	; 0x2e0 <LCD_clear+0x1e>
    {
        LCD_write_byte(0, 0);
 2d8:	60 e0       	ldi	r22, 0x00	; 0
 2da:	80 e0       	ldi	r24, 0x00	; 0
 2dc:	d3 df       	rcall	.-90     	; 0x284 <LCD_write_byte>
void LCD_clear()
{
    LCD_write_byte(0x0c, 1);
    LCD_write_byte(0x80, 1);

    for (unsigned int i = 0; i < NUM_OF_CELLS; i++)
 2de:	21 96       	adiw	r28, 0x01	; 1
 2e0:	c8 3f       	cpi	r28, 0xF8	; 248
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	d8 07       	cpc	r29, r24
 2e6:	c0 f3       	brcs	.-16     	; 0x2d8 <LCD_clear+0x16>
    {
        LCD_write_byte(0, 0);
    }
}
 2e8:	df 91       	pop	r29
 2ea:	cf 91       	pop	r28
 2ec:	08 95       	ret

000002ee <LCD_init>:
#include "english_font.h"

void LCD_init() 
{
    // Setup all pins to out
    LCD_RST_DDR |= (1 << LCD_RST_PIN);
 2ee:	84 b1       	in	r24, 0x04	; 4
 2f0:	80 62       	ori	r24, 0x20	; 32
 2f2:	84 b9       	out	0x04, r24	; 4
    LCD_CE_DDR  |= (1 << LCD_CE_PIN);
 2f4:	84 b1       	in	r24, 0x04	; 4
 2f6:	80 61       	ori	r24, 0x10	; 16
 2f8:	84 b9       	out	0x04, r24	; 4
    LCD_DC_DDR  |= (1 << LCD_DC_PIN);
 2fa:	84 b1       	in	r24, 0x04	; 4
 2fc:	88 60       	ori	r24, 0x08	; 8
 2fe:	84 b9       	out	0x04, r24	; 4
    SDIN_DDR    |= (1 << SDIN_PIN);
 300:	84 b1       	in	r24, 0x04	; 4
 302:	84 60       	ori	r24, 0x04	; 4
 304:	84 b9       	out	0x04, r24	; 4
    SCLK_DDR    |= (1 << SCLK_PIN);
 306:	8a b1       	in	r24, 0x0a	; 10
 308:	82 60       	ori	r24, 0x02	; 2
 30a:	8a b9       	out	0x0a, r24	; 10
    
    // Set CE to low, this bus is reserved for display
    LCD_CE_PORT &= ~(1 << LCD_DC_PIN);
 30c:	85 b1       	in	r24, 0x05	; 5
 30e:	87 7f       	andi	r24, 0xF7	; 247
 310:	85 b9       	out	0x05, r24	; 5
    
    // Set other pins high
    LCD_RST_PORT    |= (1 << LCD_RST_PIN);
 312:	85 b1       	in	r24, 0x05	; 5
 314:	80 62       	ori	r24, 0x20	; 32
 316:	85 b9       	out	0x05, r24	; 5
    LCD_DC_PORT     |= (1 << LCD_DC_PIN);
 318:	85 b1       	in	r24, 0x05	; 5
 31a:	88 60       	ori	r24, 0x08	; 8
 31c:	85 b9       	out	0x05, r24	; 5
    SDIN_PORT       |= (1 << SDIN_PIN);
 31e:	85 b1       	in	r24, 0x05	; 5
 320:	84 60       	ori	r24, 0x04	; 4
 322:	85 b9       	out	0x05, r24	; 5
    SCLK_PORT       |= (1 << SCLK_PIN);
 324:	85 b1       	in	r24, 0x05	; 5
 326:	82 60       	ori	r24, 0x02	; 2
 328:	85 b9       	out	0x05, r24	; 5
 32a:	8f e9       	ldi	r24, 0x9F	; 159
 32c:	9f e0       	ldi	r25, 0x0F	; 15
 32e:	01 97       	sbiw	r24, 0x01	; 1
 330:	f1 f7       	brne	.-4      	; 0x32e <LCD_init+0x40>
 332:	00 c0       	rjmp	.+0      	; 0x334 <LCD_init+0x46>
 334:	00 00       	nop
    _delay_ms(1);
    
    // Reset and setup
    LCD_RST_clr;
 336:	85 b1       	in	r24, 0x05	; 5
 338:	8f 7d       	andi	r24, 0xDF	; 223
 33a:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 33c:	95 e0       	ldi	r25, 0x05	; 5
 33e:	9a 95       	dec	r25
 340:	f1 f7       	brne	.-4      	; 0x33e <LCD_init+0x50>
 342:	00 00       	nop
    _delay_us(1);
    LCD_RST_set;
 344:	85 b1       	in	r24, 0x05	; 5
 346:	80 62       	ori	r24, 0x20	; 32
 348:	85 b9       	out	0x05, r24	; 5
 34a:	85 e0       	ldi	r24, 0x05	; 5
 34c:	8a 95       	dec	r24
 34e:	f1 f7       	brne	.-4      	; 0x34c <LCD_init+0x5e>
 350:	00 00       	nop

    _delay_us(1);

    LCD_write_byte(0x21, 1); // set LCD mode
 352:	61 e0       	ldi	r22, 0x01	; 1
 354:	81 e2       	ldi	r24, 0x21	; 33
 356:	96 df       	rcall	.-212    	; 0x284 <LCD_write_byte>
    LCD_write_byte(0xc8, 1); // set bias voltage
 358:	61 e0       	ldi	r22, 0x01	; 1
 35a:	88 ec       	ldi	r24, 0xC8	; 200
 35c:	93 df       	rcall	.-218    	; 0x284 <LCD_write_byte>
    LCD_write_byte(0x06, 1); // temperature correction
 35e:	61 e0       	ldi	r22, 0x01	; 1
 360:	86 e0       	ldi	r24, 0x06	; 6
 362:	90 df       	rcall	.-224    	; 0x284 <LCD_write_byte>
    LCD_write_byte(0x13, 1); // 1:48
 364:	61 e0       	ldi	r22, 0x01	; 1
 366:	83 e1       	ldi	r24, 0x13	; 19
 368:	8d df       	rcall	.-230    	; 0x284 <LCD_write_byte>
    LCD_write_byte(0x20, 1); // use bias command, vertical
 36a:	61 e0       	ldi	r22, 0x01	; 1
 36c:	80 e2       	ldi	r24, 0x20	; 32
    LCD_write_byte(0x0c, 1); // set LCD mode,display normally
 36e:	8a df       	rcall	.-236    	; 0x284 <LCD_write_byte>
 370:	61 e0       	ldi	r22, 0x01	; 1
 372:	8c e0       	ldi	r24, 0x0C	; 12
 374:	87 df       	rcall	.-242    	; 0x284 <LCD_write_byte>
    LCD_clear();             // clear the LCD
 376:	a5 cf       	rjmp	.-182    	; 0x2c2 <LCD_clear>
 378:	08 95       	ret

0000037a <LCD_set_XY>:
 37a:	cf 93       	push	r28
        SCLK_set;
    }
}

void LCD_set_XY(unsigned char X, unsigned char Y)
{
 37c:	c8 2f       	mov	r28, r24
 37e:	86 2f       	mov	r24, r22
    LCD_write_byte(0x40 | Y, 1);    // column
 380:	61 e0       	ldi	r22, 0x01	; 1
 382:	80 64       	ori	r24, 0x40	; 64
 384:	7f df       	rcall	.-258    	; 0x284 <LCD_write_byte>
    LCD_write_byte(0x80 | X, 1);    // row
 386:	61 e0       	ldi	r22, 0x01	; 1
 388:	8c 2f       	mov	r24, r28
 38a:	80 68       	ori	r24, 0x80	; 128
 38c:	7b df       	rcall	.-266    	; 0x284 <LCD_write_byte>
}
 38e:	cf 91       	pop	r28
 390:	08 95       	ret

00000392 <LCD_write_char>:

void LCD_write_char(unsigned char c)
{
 392:	cf 93       	push	r28
 394:	df 93       	push	r29
    unsigned char line;
    c -= 32;
 396:	d0 ee       	ldi	r29, 0xE0	; 224
 398:	d8 0f       	add	r29, r24

    for (line = 0; line < 6; line++)
 39a:	c0 e0       	ldi	r28, 0x00	; 0
 39c:	11 c0       	rjmp	.+34     	; 0x3c0 <LCD_write_char+0x2e>
        LCD_write_byte(font6x8[c][line], 0);
 39e:	8d 2f       	mov	r24, r29
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	fc 01       	movw	r30, r24
 3a4:	ee 0f       	add	r30, r30
 3a6:	ff 1f       	adc	r31, r31
 3a8:	e8 0f       	add	r30, r24
 3aa:	f9 1f       	adc	r31, r25
 3ac:	ee 0f       	add	r30, r30
 3ae:	ff 1f       	adc	r31, r31
 3b0:	ed 5f       	subi	r30, 0xFD	; 253
 3b2:	fe 4f       	sbci	r31, 0xFE	; 254
 3b4:	ec 0f       	add	r30, r28
 3b6:	f1 1d       	adc	r31, r1
 3b8:	60 e0       	ldi	r22, 0x00	; 0
 3ba:	80 81       	ld	r24, Z
 3bc:	63 df       	rcall	.-314    	; 0x284 <LCD_write_byte>
void LCD_write_char(unsigned char c)
{
    unsigned char line;
    c -= 32;

    for (line = 0; line < 6; line++)
 3be:	cf 5f       	subi	r28, 0xFF	; 255
 3c0:	c6 30       	cpi	r28, 0x06	; 6
 3c2:	68 f3       	brcs	.-38     	; 0x39e <LCD_write_char+0xc>
        LCD_write_byte(font6x8[c][line], 0);
}
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	08 95       	ret

000003ca <LCD_write_english_string>:

void LCD_write_english_string(unsigned char X, unsigned char Y, char *s)
{
 3ca:	cf 93       	push	r28
 3cc:	df 93       	push	r29
 3ce:	ea 01       	movw	r28, r20
    LCD_set_XY(X,Y);
 3d0:	d4 df       	rcall	.-88     	; 0x37a <LCD_set_XY>
    while (*s)
    {
        LCD_write_char(*s);
 3d2:	02 c0       	rjmp	.+4      	; 0x3d8 <LCD_write_english_string+0xe>
 3d4:	de df       	rcall	.-68     	; 0x392 <LCD_write_char>
        s++;
 3d6:	21 96       	adiw	r28, 0x01	; 1
}

void LCD_write_english_string(unsigned char X, unsigned char Y, char *s)
{
    LCD_set_XY(X,Y);
    while (*s)
 3d8:	88 81       	ld	r24, Y
 3da:	81 11       	cpse	r24, r1
 3dc:	fb cf       	rjmp	.-10     	; 0x3d4 <LCD_write_english_string+0xa>
    {
        LCD_write_char(*s);
        s++;
    }
}
 3de:	df 91       	pop	r29
 3e0:	cf 91       	pop	r28
 3e2:	08 95       	ret

000003e4 <LCD_write_whole_screen>:

void LCD_write_whole_screen(unsigned char *cells, uint16_t cells_n, uint16_t start_y) {
 3e4:	ef 92       	push	r14
 3e6:	ff 92       	push	r15
 3e8:	0f 93       	push	r16
 3ea:	1f 93       	push	r17
 3ec:	cf 93       	push	r28
 3ee:	df 93       	push	r29
 3f0:	7c 01       	movw	r14, r24
 3f2:	8b 01       	movw	r16, r22
    LCD_set_XY(0, (unsigned char) start_y);
 3f4:	64 2f       	mov	r22, r20
 3f6:	80 e0       	ldi	r24, 0x00	; 0
 3f8:	c0 df       	rcall	.-128    	; 0x37a <LCD_set_XY>
    for (uint16_t i = 0; i < cells_n; i++)
 3fa:	c0 e0       	ldi	r28, 0x00	; 0
 3fc:	d0 e0       	ldi	r29, 0x00	; 0
 3fe:	07 c0       	rjmp	.+14     	; 0x40e <__EEPROM_REGION_LENGTH__+0xe>
        LCD_write_byte(cells[i], 0);
 400:	f7 01       	movw	r30, r14
 402:	ec 0f       	add	r30, r28
 404:	fd 1f       	adc	r31, r29
 406:	60 e0       	ldi	r22, 0x00	; 0
 408:	80 81       	ld	r24, Z
 40a:	3c df       	rcall	.-392    	; 0x284 <LCD_write_byte>
    }
}

void LCD_write_whole_screen(unsigned char *cells, uint16_t cells_n, uint16_t start_y) {
    LCD_set_XY(0, (unsigned char) start_y);
    for (uint16_t i = 0; i < cells_n; i++)
 40c:	21 96       	adiw	r28, 0x01	; 1
 40e:	c0 17       	cp	r28, r16
 410:	d1 07       	cpc	r29, r17
 412:	b0 f3       	brcs	.-20     	; 0x400 <__EEPROM_REGION_LENGTH__>
        LCD_write_byte(cells[i], 0);
}
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	1f 91       	pop	r17
 41a:	0f 91       	pop	r16
 41c:	ff 90       	pop	r15
 41e:	ef 90       	pop	r14
 420:	08 95       	ret

00000422 <LCD_write_init>:

void LCD_write_init()
{
    LCD_clear();
 422:	4f df       	rcall	.-354    	; 0x2c2 <LCD_clear>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 424:	2f ef       	ldi	r18, 0xFF	; 255
 426:	83 ed       	ldi	r24, 0xD3	; 211
 428:	90 e3       	ldi	r25, 0x30	; 48
 42a:	21 50       	subi	r18, 0x01	; 1
 42c:	80 40       	sbci	r24, 0x00	; 0
 42e:	90 40       	sbci	r25, 0x00	; 0
 430:	e1 f7       	brne	.-8      	; 0x42a <LCD_write_init+0x8>
 432:	00 c0       	rjmp	.+0      	; 0x434 <LCD_write_init+0x12>
 434:	00 00       	nop
    _delay_ms(1000);
    LCD_write_whole_screen((unsigned char*) init_msg_2, NUM_OF_CELLS, 0);    
 436:	40 e0       	ldi	r20, 0x00	; 0
 438:	50 e0       	ldi	r21, 0x00	; 0
 43a:	68 ef       	ldi	r22, 0xF8	; 248
 43c:	71 e0       	ldi	r23, 0x01	; 1
 43e:	8b e2       	ldi	r24, 0x2B	; 43
 440:	93 e0       	ldi	r25, 0x03	; 3
 442:	d0 cf       	rjmp	.-96     	; 0x3e4 <LCD_write_whole_screen>
 444:	08 95       	ret

00000446 <__fixunssfsi>:
 446:	33 d0       	rcall	.+102    	; 0x4ae <__fp_splitA>
 448:	88 f0       	brcs	.+34     	; 0x46c <__fixunssfsi+0x26>
 44a:	9f 57       	subi	r25, 0x7F	; 127
 44c:	90 f0       	brcs	.+36     	; 0x472 <__fixunssfsi+0x2c>
 44e:	b9 2f       	mov	r27, r25
 450:	99 27       	eor	r25, r25
 452:	b7 51       	subi	r27, 0x17	; 23
 454:	a0 f0       	brcs	.+40     	; 0x47e <__fixunssfsi+0x38>
 456:	d1 f0       	breq	.+52     	; 0x48c <__fixunssfsi+0x46>
 458:	66 0f       	add	r22, r22
 45a:	77 1f       	adc	r23, r23
 45c:	88 1f       	adc	r24, r24
 45e:	99 1f       	adc	r25, r25
 460:	1a f0       	brmi	.+6      	; 0x468 <__fixunssfsi+0x22>
 462:	ba 95       	dec	r27
 464:	c9 f7       	brne	.-14     	; 0x458 <__fixunssfsi+0x12>
 466:	12 c0       	rjmp	.+36     	; 0x48c <__fixunssfsi+0x46>
 468:	b1 30       	cpi	r27, 0x01	; 1
 46a:	81 f0       	breq	.+32     	; 0x48c <__fixunssfsi+0x46>
 46c:	3a d0       	rcall	.+116    	; 0x4e2 <__fp_zero>
 46e:	b1 e0       	ldi	r27, 0x01	; 1
 470:	08 95       	ret
 472:	37 c0       	rjmp	.+110    	; 0x4e2 <__fp_zero>
 474:	67 2f       	mov	r22, r23
 476:	78 2f       	mov	r23, r24
 478:	88 27       	eor	r24, r24
 47a:	b8 5f       	subi	r27, 0xF8	; 248
 47c:	39 f0       	breq	.+14     	; 0x48c <__fixunssfsi+0x46>
 47e:	b9 3f       	cpi	r27, 0xF9	; 249
 480:	cc f3       	brlt	.-14     	; 0x474 <__fixunssfsi+0x2e>
 482:	86 95       	lsr	r24
 484:	77 95       	ror	r23
 486:	67 95       	ror	r22
 488:	b3 95       	inc	r27
 48a:	d9 f7       	brne	.-10     	; 0x482 <__fixunssfsi+0x3c>
 48c:	3e f4       	brtc	.+14     	; 0x49c <__fixunssfsi+0x56>
 48e:	90 95       	com	r25
 490:	80 95       	com	r24
 492:	70 95       	com	r23
 494:	61 95       	neg	r22
 496:	7f 4f       	sbci	r23, 0xFF	; 255
 498:	8f 4f       	sbci	r24, 0xFF	; 255
 49a:	9f 4f       	sbci	r25, 0xFF	; 255
 49c:	08 95       	ret

0000049e <__fp_split3>:
 49e:	57 fd       	sbrc	r21, 7
 4a0:	90 58       	subi	r25, 0x80	; 128
 4a2:	44 0f       	add	r20, r20
 4a4:	55 1f       	adc	r21, r21
 4a6:	59 f0       	breq	.+22     	; 0x4be <__fp_splitA+0x10>
 4a8:	5f 3f       	cpi	r21, 0xFF	; 255
 4aa:	71 f0       	breq	.+28     	; 0x4c8 <__fp_splitA+0x1a>
 4ac:	47 95       	ror	r20

000004ae <__fp_splitA>:
 4ae:	88 0f       	add	r24, r24
 4b0:	97 fb       	bst	r25, 7
 4b2:	99 1f       	adc	r25, r25
 4b4:	61 f0       	breq	.+24     	; 0x4ce <__fp_splitA+0x20>
 4b6:	9f 3f       	cpi	r25, 0xFF	; 255
 4b8:	79 f0       	breq	.+30     	; 0x4d8 <__fp_splitA+0x2a>
 4ba:	87 95       	ror	r24
 4bc:	08 95       	ret
 4be:	12 16       	cp	r1, r18
 4c0:	13 06       	cpc	r1, r19
 4c2:	14 06       	cpc	r1, r20
 4c4:	55 1f       	adc	r21, r21
 4c6:	f2 cf       	rjmp	.-28     	; 0x4ac <__fp_split3+0xe>
 4c8:	46 95       	lsr	r20
 4ca:	f1 df       	rcall	.-30     	; 0x4ae <__fp_splitA>
 4cc:	08 c0       	rjmp	.+16     	; 0x4de <__fp_splitA+0x30>
 4ce:	16 16       	cp	r1, r22
 4d0:	17 06       	cpc	r1, r23
 4d2:	18 06       	cpc	r1, r24
 4d4:	99 1f       	adc	r25, r25
 4d6:	f1 cf       	rjmp	.-30     	; 0x4ba <__fp_splitA+0xc>
 4d8:	86 95       	lsr	r24
 4da:	71 05       	cpc	r23, r1
 4dc:	61 05       	cpc	r22, r1
 4de:	08 94       	sec
 4e0:	08 95       	ret

000004e2 <__fp_zero>:
 4e2:	e8 94       	clt

000004e4 <__fp_szero>:
 4e4:	bb 27       	eor	r27, r27
 4e6:	66 27       	eor	r22, r22
 4e8:	77 27       	eor	r23, r23
 4ea:	cb 01       	movw	r24, r22
 4ec:	97 f9       	bld	r25, 7
 4ee:	08 95       	ret

000004f0 <__udivmodsi4>:
 4f0:	a1 e2       	ldi	r26, 0x21	; 33
 4f2:	1a 2e       	mov	r1, r26
 4f4:	aa 1b       	sub	r26, r26
 4f6:	bb 1b       	sub	r27, r27
 4f8:	fd 01       	movw	r30, r26
 4fa:	0d c0       	rjmp	.+26     	; 0x516 <__udivmodsi4_ep>

000004fc <__udivmodsi4_loop>:
 4fc:	aa 1f       	adc	r26, r26
 4fe:	bb 1f       	adc	r27, r27
 500:	ee 1f       	adc	r30, r30
 502:	ff 1f       	adc	r31, r31
 504:	a2 17       	cp	r26, r18
 506:	b3 07       	cpc	r27, r19
 508:	e4 07       	cpc	r30, r20
 50a:	f5 07       	cpc	r31, r21
 50c:	20 f0       	brcs	.+8      	; 0x516 <__udivmodsi4_ep>
 50e:	a2 1b       	sub	r26, r18
 510:	b3 0b       	sbc	r27, r19
 512:	e4 0b       	sbc	r30, r20
 514:	f5 0b       	sbc	r31, r21

00000516 <__udivmodsi4_ep>:
 516:	66 1f       	adc	r22, r22
 518:	77 1f       	adc	r23, r23
 51a:	88 1f       	adc	r24, r24
 51c:	99 1f       	adc	r25, r25
 51e:	1a 94       	dec	r1
 520:	69 f7       	brne	.-38     	; 0x4fc <__udivmodsi4_loop>
 522:	60 95       	com	r22
 524:	70 95       	com	r23
 526:	80 95       	com	r24
 528:	90 95       	com	r25
 52a:	9b 01       	movw	r18, r22
 52c:	ac 01       	movw	r20, r24
 52e:	bd 01       	movw	r22, r26
 530:	cf 01       	movw	r24, r30
 532:	08 95       	ret

00000534 <__itoa_ncheck>:
 534:	bb 27       	eor	r27, r27
 536:	4a 30       	cpi	r20, 0x0A	; 10
 538:	31 f4       	brne	.+12     	; 0x546 <__itoa_ncheck+0x12>
 53a:	99 23       	and	r25, r25
 53c:	22 f4       	brpl	.+8      	; 0x546 <__itoa_ncheck+0x12>
 53e:	bd e2       	ldi	r27, 0x2D	; 45
 540:	90 95       	com	r25
 542:	81 95       	neg	r24
 544:	9f 4f       	sbci	r25, 0xFF	; 255
 546:	01 c0       	rjmp	.+2      	; 0x54a <__utoa_common>

00000548 <__utoa_ncheck>:
 548:	bb 27       	eor	r27, r27

0000054a <__utoa_common>:
 54a:	fb 01       	movw	r30, r22
 54c:	55 27       	eor	r21, r21
 54e:	aa 27       	eor	r26, r26
 550:	88 0f       	add	r24, r24
 552:	99 1f       	adc	r25, r25
 554:	aa 1f       	adc	r26, r26
 556:	a4 17       	cp	r26, r20
 558:	10 f0       	brcs	.+4      	; 0x55e <__utoa_common+0x14>
 55a:	a4 1b       	sub	r26, r20
 55c:	83 95       	inc	r24
 55e:	50 51       	subi	r21, 0x10	; 16
 560:	b9 f7       	brne	.-18     	; 0x550 <__utoa_common+0x6>
 562:	a0 5d       	subi	r26, 0xD0	; 208
 564:	aa 33       	cpi	r26, 0x3A	; 58
 566:	08 f0       	brcs	.+2      	; 0x56a <__utoa_common+0x20>
 568:	a9 5d       	subi	r26, 0xD9	; 217
 56a:	a1 93       	st	Z+, r26
 56c:	00 97       	sbiw	r24, 0x00	; 0
 56e:	79 f7       	brne	.-34     	; 0x54e <__utoa_common+0x4>
 570:	b1 11       	cpse	r27, r1
 572:	b1 93       	st	Z+, r27
 574:	11 92       	st	Z+, r1
 576:	cb 01       	movw	r24, r22
 578:	00 c0       	rjmp	.+0      	; 0x57a <strrev>

0000057a <strrev>:
 57a:	dc 01       	movw	r26, r24
 57c:	fc 01       	movw	r30, r24
 57e:	67 2f       	mov	r22, r23
 580:	71 91       	ld	r23, Z+
 582:	77 23       	and	r23, r23
 584:	e1 f7       	brne	.-8      	; 0x57e <strrev+0x4>
 586:	32 97       	sbiw	r30, 0x02	; 2
 588:	04 c0       	rjmp	.+8      	; 0x592 <strrev+0x18>
 58a:	7c 91       	ld	r23, X
 58c:	6d 93       	st	X+, r22
 58e:	70 83       	st	Z, r23
 590:	62 91       	ld	r22, -Z
 592:	ae 17       	cp	r26, r30
 594:	bf 07       	cpc	r27, r31
 596:	c8 f3       	brcs	.-14     	; 0x58a <strrev+0x10>
 598:	08 95       	ret

0000059a <_exit>:
 59a:	f8 94       	cli

0000059c <__stop_program>:
 59c:	ff cf       	rjmp	.-2      	; 0x59c <__stop_program>
